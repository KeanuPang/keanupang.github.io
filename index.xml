<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Living today for tomorrow</title><link>https://keanupang.github.io/</link><description>Recent content on Living today for tomorrow</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 28 Jun 2022 02:05:11 +0800</lastBuildDate><atom:link href="https://keanupang.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>試玩 Hummingbird 的 middleware</title><link>https://keanupang.github.io/posts/side-project-hummingbird-localweb/</link><pubDate>Tue, 28 Jun 2022 02:05:11 +0800</pubDate><guid>https://keanupang.github.io/posts/side-project-hummingbird-localweb/</guid><description>之前為了測試 Hummingbird 這個輕量 server framework 所以做了一個叫 LocalWeb 的 web project，主要是用來讓使用者在開發環境下方便地瀏覽與下載檔案；結果沒想到內建的 middleware 就幾乎把所有事情都搞定了。
當然還是要再加點工才可以方便使用，例如當我點進目錄時，希望可以一覽目錄下的檔案清單，所以就客製化做了個 middleware 掛上來，把目錄下的檔案展開成清單做成連結讓使用者可以下載，當使用者點到檔案時就直接串到 HBFileMiddleware 下載檔案這樣。
第一次嘗試實作 Hummingbird 的 middleware 所以花了點時間研究，目前實作版本可以參考這 DirectoryIndexMiddleware ，還好進入門檻不高就是，花最多時間反而是在刻呈現頁面的 html。
因為想呈現那種傳統 Apache web server 檢視目錄下的復古感，於是參考 HBResponseGenerator 這個 protocol，是用來產生 response 結果頁，基本上只要實作 func response(from request: HBRequest) 把刻好的 html 產生成 HBResponse 結果就可以。
成品像是這樣 DirectoryIndexPage 會在剛剛的 DirectoryIndexMiddleware 裡被用到回傳 response。
為了求快所以先不套用什麼 template engine，直接用 String 拼出來，之後有時間再研究看看 Stencil 還是 Leaf 哪個好用。
雛型差不多完成之後，想說要掛個 HTTPS 功能結果好像沒有那麼直覺。本來以為只要把 Configuration 裡的 tlsOptions 設定上去就好，然後就會被噴 warning 訊息：
tlsOptions set in Configuration will not be applied to a BSD sockets server.</description></item><item><title>About Me</title><link>https://keanupang.github.io/about/</link><pubDate>Wed, 22 Jun 2022 13:45:57 +0800</pubDate><guid>https://keanupang.github.io/about/</guid><description/></item><item><title>幾個 WebView 互動功能筆記</title><link>https://keanupang.github.io/posts/ios-webview-note/</link><pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/ios-webview-note/</guid><description>好像只有在亞洲地區才流行這樣的組合，也就是從 native app 畫面開 web view 切到行銷活動網頁，再透過 javascript 方式跟 app 互動之後回到 app 裡進行後面的導頁與串行銷資料。
同步切換 app 畫面標題 為了要讓 webView 載入的網頁標題也能貼回到 App 裡的 navigation bar 上，所以在 viewDidLoad() 的時候，加上 addObserver：
webView.addObserver(self, forKeyPath: #keyPath(WKWebView.title), options: .new, context: nil) 為了避免 leak，若有開啟 addObserver 更新 title 的話，在 ViewController dismiss 時要移除掉：
webView.removeObserver(self, forKeyPath: &amp;#34;title&amp;#34;) 顯示與取消 Loading 對應到 WKNavigationDelegate 可以透過下方兩個 methods 顯示或取消自訂的 loading view：
func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) { guard isBeingDismissed || isMovingFromParent else { // present loading view return } } func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!</description></item><item><title>Snapshot Testing 的調整經驗筆記</title><link>https://keanupang.github.io/posts/ios-snapshot-testing-note/</link><pubDate>Wed, 02 Mar 2022 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/ios-snapshot-testing-note/</guid><description>我們的專案已經有 816 snapshot tests 並且有 600 張 snapshots，對專案的 coverage 約 47%，對產品的品質信心算是滿足夠的。
常被抱怨的點是在 CI 上跑 unit test 的時間太久，以專案 800 多個 snapshot tests 來說需要花上 15 mins 才能跑完，有時候開的 PR 一多幾乎都是在等待 unit test 跑結束，反而有點浪費在等待，目前只能採取折衷的作法，在特定的 branch 才啟動 unit test。
另外遇到的問題是不同機器配上對應的模擬器有時候會發生圖片”看起來”是一樣內容，但檔案大小卻差了幾個 bytes，所以程式比對圖片就直接認定 assert failed。原因是畫面在截取的當下可能仍會因為動畫等視覺效果，而造成產生的 snapshot 有些微色彩的差異。
這類問題的解法目前是走 duplicate image detection 的做法，也就是算出 snapshot 對應的 hash 值，然後將兩張圖片的 hash 根據 Hamming distance 來評估是不是一樣的圖片。
本來是在這邊 GitHub – benhoyt/dhash 看到這個，查了一下大概就是這幾種 hash 方法的比較，來源是 GitHub – ameingast/cocoaimagehashing 這裡：
Name Performance Quality aHash good bad dHash excellent good pHash bad excellent 其實滿推崇 pHash 的方法，看 別人分享 iOS 上測試的過程 具有很多優勢；但因為 dHash 實作上相對容易，也滿多實作的作品可以參考。自己參考的實作是這兩篇：</description></item><item><title>Some useful CLI tools for myself</title><link>https://keanupang.github.io/posts/useful_cli_tools_for_myself/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/useful_cli_tools_for_myself/</guid><description>列幾個針對檔案操作的 CLI 工具是我在平日工作時比較常會用到的，最常用的就是 AG 了，在查找專案目錄下的特定關鍵字顯得非常方便快速。
AG: 用來查找目錄下的所有符合指定文字的檔案內容 fd: 用來查找目錄下所有符合指定文字的檔名 bat: 替換 cat 指令的好工具 sd: 尋找與取代指定檔案裡的文字內容，快又有效</description></item><item><title>ArangoDB 的資料檔備份與還原</title><link>https://keanupang.github.io/posts/arangodb_data_dump_and_restore/</link><pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/arangodb_data_dump_and_restore/</guid><description>之前在測試 ArangoDB 操作特別註記下來的小筆記。
建立 dump unix&amp;gt; arangodump --server.endpoint tcp://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt; --server.database &amp;lt;database&amp;gt; --include-system-collections --collection _graphs --collection imdb_vertices --collection imdb_edges --compress-output false --envelope true 還原資料 準備好之前 dump 的資料，目前名為 dump，再執行如下指令，預設會找當前目錄下的 dump 目錄：
unix&amp;gt; arangorestore --server.endpoint tcp://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt; --server.database IMDB --create-database --include-system-collections</description></item><item><title>快速實驗與驗證功能的小工具 swift-sh</title><link>https://keanupang.github.io/posts/tool_swift_sh_for_prototyping/</link><pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/tool_swift_sh_for_prototyping/</guid><description>OK, 我們現在可以用 swift-sh 工具預先安裝到系統裡，這樣子之後只要做小型測試時只要單一個 swift 檔案，裡面標註 import 的敘述，就可以直接執行它。
先安裝好 swift-sh 工具：
brew install swift-sh 然後就可以開始編寫 swift 檔案做小型的驗證：
#!/usr/bin/swift sh import Foundation import PromiseKit // @mxcl ~&amp;gt; 6.5 firstly { after(.seconds(2)) }.then { after(.milliseconds(500)) }.done { print(&amp;#34;notice: two and a half seconds elapsed&amp;#34;) exit(0) } RunLoop.main.run() 要記得檔案最前面的 shebang 要寫明 #!/usr/bin/swift sh 的敘述，這樣系統才會去觸發 swift-sh 工具來處理；以及 import 第三方套件時，要在該行的最後加上註解是哪個 SwiftPM 的來源，甚至可以標註版本。
最後只要把這個檔案加上可執行權限就可以直接執行了。</description></item><item><title>工程師的成長</title><link>https://keanupang.github.io/posts/web-share-limboy-eng-growth/</link><pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/web-share-limboy-eng-growth/</guid><description>https://limboy.me/2021/06/29/eng-growth
我覺得這篇寫算不錯，把一些必備的項目要點都有列出，對我來說反而是以下幾點比較關鍵：
累積 credit 信用值，才能提升影響力，講話才能大聲，別人才聽得進去 向各類型不同的夥伴學習他們的長處，儘管他們有著自己在意的缺點也沒關係，只要把重點擺在他們的長處並學習 如果對方是你欣賞的，要珍惜與他們共事的時間，遇到問題時，了解他們怎麼看待、處理、解決問題的</description></item><item><title>BehaviorRelay 筆記</title><link>https://keanupang.github.io/posts/behavior-relay-note/</link><pubDate>Tue, 26 Oct 2021 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/behavior-relay-note/</guid><description>因為是單向的資訊流，在每次更新資訊時都是用 .accept 送出最近資訊，所以最好的做法是如果本身的資訊是組合性的 struct 則拆開成數個 BehaviorRelay 各別更新會比較好，這樣綁定在不同的 UIView 元件會比較好處理。
例如本來是長這樣：
struct Info { var propertyA: Bool = false var propertyB: Bool = false var propertyC: Bool = false } 就拆成三個 property 各自維護：
let propertyA = BehaviorRelay&amp;lt;Bool&amp;gt;(value: false) let propertyB = BehaviorRelay&amp;lt;Bool&amp;gt;(value: false) let propertyC = BehaviorRelay&amp;lt;Bool&amp;gt;(value: false) 然後就可以在 ViewController 層各別 Driver 綁定； 在最後如果需要組合判斷時才在用 Observable.combineLatest 來處理，例如：
var isEnable: Driver&amp;lt;Bool&amp;gt; { return Observable.combineLatest(propertyA, propertyB, propertyC) .map { $0 &amp;amp;&amp;amp; $1 &amp;amp;&amp;amp; $2 } .</description></item><item><title>Failable Initializer 筆記</title><link>https://keanupang.github.io/posts/failable_initializer/</link><pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/failable_initializer/</guid><description>之前在 這篇文章 看到的。
將自己的 class 來做出一個可以是 optional 的物件，這樣一來使用的時候就必須用 if-let 或 guard 來讀取，在程式上會比較好理解跟處理。
直接上 code：
class FilteredImage { ... init?(with imageName: String) { guard let image = UIImage(named: imageName) else { return nil } self.image = image } } 也就是說在初始化時是用 init? 的方式，確保回傳得到的物件要嘛是 nil 要嘛真的有值，而且對應的屬性也保證有值。
使用上也因為初始化回傳的是 optional 物件，限制了使用者必須用 if-let 或 guard 來拿取：
guard let filteredImage = FilteredImage(with: &amp;#34;bird&amp;#34;) else { // filteredImage is nil return } // filteredImage is initialized and we use it normally 然後要保持一個原則，回傳是 nil 一定是因為初始化失敗而得到的，如果是後面的行為造成的話等於權責不分無法抓住問題：</description></item><item><title>曾幾何時，人生的種種行為必須要虛偽的表現才算是正常了</title><link>https://keanupang.github.io/posts/hypocritical-person-in-my-life/</link><pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/hypocritical-person-in-my-life/</guid><description>自己所說的話所做的事，這些行為都要做的很表面做到位，對方才能夠體會到那所謂的”誠意”，很像電視節目的八點檔戲劇對話般，要正面有多正面，要積極就給到超過 100 分的積極。
對自己來說，大概也只剩下在停車場停完車後坐在駕駛座上遲遲不走的那時刻，才能感覺到真實自己的存在吧。</description></item><item><title>建立 DynamoDB 的 Incremental ID 機制</title><link>https://keanupang.github.io/posts/dynamodb-incremental-id/</link><pubDate>Tue, 12 Dec 2017 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/dynamodb-incremental-id/</guid><description>需要在 DynamoDB 的某個 table 的 Hash Key 是用 auto increment 的方式儲存 id，不過如果只單靠一張 table 有點難完成這樣的機制，所以需要再生另一張 table 用來存放目前的值，讓原本的 table 可以去參考以取得新增後的數值回來儲存。
可以參考這篇：How to make a UUID in DynamoDB?，做法大概就是像這樣：
Each time you want to generate a new id, you would do the following:
Do a GetItem on NextIdTable to read the current value of Counter → curValue
Do a PutItem on NextIdTable to set the value of Counter to curValue + 1. Make this a conditional &amp;gt; PutItem so that it will fail if the value of Counter has changed.</description></item><item><title>在 Observable 裡做 recursive 操作</title><link>https://keanupang.github.io/posts/rxjs-expand-operator/</link><pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/rxjs-expand-operator/</guid><description>請參考 expand operator 的說明：
Recursively projects each source value to an Observable which is merged in the output Observable. 在 expand operator 裡主要的判斷是如果離開這個 recursion 就回傳 Rx.Observable.empty()；反之就把需要 recursive 的值修改後再回傳 Observable 物件，於是你的 Observable 物件就可以做類似 loop 的叫用串接了。
小範例如下，是用 AVA 做 test runner：
const Rx = require(&amp;#39;rxjs&amp;#39;); const winston = require(&amp;#39;winston&amp;#39;); const test = require(&amp;#39;ava&amp;#39;); const fetchObs = (count) =&amp;gt; { return Rx.Observable.of({value: count, count: count*2}); }; test(&amp;#39;test expand&amp;#39;, (t) =&amp;gt; { return fetchObs(1) .</description></item><item><title>Connect-Redis 套件更新 Session 過期時間的方式</title><link>https://keanupang.github.io/posts/configure-redis-session-timeout/</link><pubDate>Mon, 14 Nov 2016 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/configure-redis-session-timeout/</guid><description>在使用 Express 架設網站時，且因為 cluster 的考量，會將 Session cookie 的資訊往外拉，通常都是使用 Redis 來儲存使用者的 Session。在 Express 裡會透過 connect-redis 的套件來串接兩者，以及使用者登入的檢查就使用 passport 套件來幫我們完成。
在 Express 裡的設定結構大概會是這樣︰
let sessionMiddleware = session({ store: new RedisStore({ host: hostname, port: port, db: db * 1, ttl: 3600 }), resave: false, saveUninitialized: false }); app.middleware(‘session’, sessionMiddleware); 這時候的困難點會是當未登入的使用者可能需要 session cookie 的 maxAge 會比較短期，例如需要是處在 recaptcha 的驗證階段；直到使用者順利登入後，才需要更新 session cookie 的 maxAge 為合理的時間。也就是 Redis 的 TTL 設定是動態的方式調整。
參考這裡的 討論 的做法則會是固定將 TTL 設為 0，並在使用者登入後才更新 maxAge。所以 RedisStore 的設定將會是︰</description></item><item><title>自定 Retrofit 的 DELETE Annotation</title><link>https://keanupang.github.io/posts/custom-retrofit-delete-annotation/</link><pubDate>Wed, 04 May 2016 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/custom-retrofit-delete-annotation/</guid><description>一般使用 Jersey 或 RESTEasy 所建立的 JAX-RS Web Service，是允許 client 呼叫 DELETE method 時可以加上 Message Body，就跟 POST method 一樣我們可以取得 Body 裡的內容。
但 Client 如果是使用 Retrofit 來呼叫 Web Service 的 DELETE method 並且加上 Body annotation 夾帶資料過去時，卻會得到如下的訊息而被中止︰
Non-body HTTP method cannot contain @Body or @TypedOutput. 對 Retrofit 來說是照著 W3C 的標準去實作，於是這樣的行為就跟一般坊間的 http client 不太一樣。
最快的方法就是自定一個可以允許夾帶資料的 DELETE Annotation，讓 Retrofit 可以參照︰
import static java.lang.annotation.ElementType.METHOD; import static java.lang.annotation.RetentionPolicy.RUNTIME; import java.lang.annotation.Retention; import java.lang.annotation.Target; import retrofit.http.RestMethod; @Target(METHOD) @Retention(RUNTIME) @RestMethod(value = “DELETE”, hasBody = true) public @interface DELETE { String value(); } 然後在自己的 Retrofit Service 使用這個 DELETE annotation 就可以了︰</description></item><item><title>Create a Self-Signed Certificate</title><link>https://keanupang.github.io/posts/create-self-signed-certificate/</link><pubDate>Sat, 30 Apr 2016 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/create-self-signed-certificate/</guid><description>在工作上因為每過一陣子就會用到，但又常常忘記步驟所以筆記一下。
先用 opeenssl 指令產生私鑰跟 CSR 檔︰
openssl req -x509 -sha256 -days 3652 -newkey rsa:2048 -keyout server.key -out server.csr 建立憑證檔案︰
openssl x509 -sha256 -days 3652 -in server.csr -signkey server.key -out selfsigned.crt 將剛剛的憑證檔案轉成 P12 格式︰
openssl pkcs12 -export -name cert_server -in selfsigned.crt -inkey server.key -out keystore.p12 最後透過 Java 的 keytool 工具轉成適合 Java 環境使用的 JKS 格式憑證檔案︰
keytool -importkeystore -destkeystore keystore.jks -srckeystore keystore.p12 -srcstoretype pkcs12 -alias cert_server 完成收工。</description></item></channel></rss>