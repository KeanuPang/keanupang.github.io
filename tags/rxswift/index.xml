<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>rxswift on Living today for tomorrow</title><link>http://localhost/tags/rxswift/</link><description>Recent content in rxswift on Living today for tomorrow</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 26 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost/tags/rxswift/index.xml" rel="self" type="application/rss+xml"/><item><title>BehaviorRelay 筆記</title><link>http://localhost/posts/behavior-relay-note/</link><pubDate>Tue, 26 Oct 2021 00:00:00 +0000</pubDate><guid>http://localhost/posts/behavior-relay-note/</guid><description>因為是單向的資訊流，在每次更新資訊時都是用 .accept 送出最近資訊，所以最好的做法是如果本身的資訊是組合性的 struct 則拆開成數個 BehaviorRelay 各別更新會比較好，這樣綁定在不同的 UIView 元件會比較好處理。
例如本來是長這樣：
struct Info { var propertyA: Bool = false var propertyB: Bool = false var propertyC: Bool = false } 就拆成三個 property 各自維護：
let propertyA = BehaviorRelay&amp;lt;Bool&amp;gt;(value: false) let propertyB = BehaviorRelay&amp;lt;Bool&amp;gt;(value: false) let propertyC = BehaviorRelay&amp;lt;Bool&amp;gt;(value: false) 然後就可以在 ViewController 層各別 Driver 綁定； 在最後如果需要組合判斷時才在用 Observable.combineLatest 來處理，例如：
var isEnable: Driver&amp;lt;Bool&amp;gt; { return Observable.combineLatest(propertyA, propertyB, propertyC) .map { $0 &amp;amp;&amp;amp; $1 &amp;amp;&amp;amp; $2 } .</description></item></channel></rss>