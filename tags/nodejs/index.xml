<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>nodejs on Living today for tomorrow</title><link>http://localhost/tags/nodejs/</link><description>Recent content in nodejs on Living today for tomorrow</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 14 Nov 2016 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost/tags/nodejs/index.xml" rel="self" type="application/rss+xml"/><item><title>Connect-Redis 套件更新 Session 過期時間的方式</title><link>http://localhost/posts/configure-redis-session-timeout/</link><pubDate>Mon, 14 Nov 2016 00:00:00 +0000</pubDate><guid>http://localhost/posts/configure-redis-session-timeout/</guid><description>在使用 Express 架設網站時，且因為 cluster 的考量，會將 Session cookie 的資訊往外拉，通常都是使用 Redis 來儲存使用者的 Session。在 Express 裡會透過 connect-redis 的套件來串接兩者，以及使用者登入的檢查就使用 passport 套件來幫我們完成。
在 Express 裡的設定結構大概會是這樣︰
let sessionMiddleware = session({ store: new RedisStore({ host: hostname, port: port, db: db * 1, ttl: 3600 }), resave: false, saveUninitialized: false }); app.middleware(‘session’, sessionMiddleware); 這時候的困難點會是當未登入的使用者可能需要 session cookie 的 maxAge 會比較短期，例如需要是處在 recaptcha 的驗證階段；直到使用者順利登入後，才需要更新 session cookie 的 maxAge 為合理的時間。也就是 Redis 的 TTL 設定是動態的方式調整。
參考這裡的 討論 的做法則會是固定將 TTL 設為 0，並在使用者登入後才更新 maxAge。所以 RedisStore 的設定將會是︰</description></item></channel></rss>