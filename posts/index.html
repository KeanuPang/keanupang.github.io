<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Living today for tomorrow</title><meta name=keywords content><meta name=description content="Posts - Living today for tomorrow"><meta name=author content="Keanu Pang"><link rel=canonical href=https://keanupang.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><link rel=icon href=https://keanupang.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://keanupang.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://keanupang.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://keanupang.github.io/apple-touch-icon.png><link rel=mask-icon href=https://keanupang.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://keanupang.github.io/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content="Living today for tomorrow"><meta property="og:type" content="website"><meta property="og:url" content="https://keanupang.github.io/posts/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Living today for tomorrow"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://keanupang.github.io/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://keanupang.github.io accesskey=h title="Living today for tomorrow (Alt + H)">Living today for tomorrow</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://keanupang.github.io/about title=About><span>About</span></a></li><li><a href=https://keanupang.github.io/posts title=Posts><span class=active>Posts</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>幾個 WebView 互動功能筆記</h2></header><div class=entry-content><p>好像只有在亞洲地區才流行這樣的組合，也就是從 native app 畫面開 web view 切到行銷活動網頁，再透過 javascript 方式跟 app 互動之後回到 app 裡進行後面的導頁與串行銷資料。
同步切換 app 畫面標題 為了要讓 webView 載入的網頁標題也能貼回到 App 裡的 navigation bar 上，所以在 viewDidLoad() 的時候，加上 addObserver：
webView.addObserver(self, forKeyPath: #keyPath(WKWebView.title), options: .new, context: nil) 為了避免 leak，若有開啟 addObserver 更新 title 的話，在 ViewController dismiss 時要移除掉：
webView.removeObserver(self, forKeyPath: "title") 顯示與取消 Loading 對應到 WKNavigationDelegate 可以透過下方兩個 methods 顯示或取消自訂的 loading view：
func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) { guard isBeingDismissed || isMovingFromParent else { // present loading view return } } func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!...</p></div><footer class=entry-footer><span title='2022-03-22 00:00:00 +0000 UTC'>March 22, 2022</span>&nbsp;·&nbsp;Keanu Pang</footer><a class=entry-link aria-label="post link to 幾個 WebView 互動功能筆記" href=https://keanupang.github.io/posts/ios-webview-note/></a></article><article class=post-entry><header class=entry-header><h2>Snapshot Testing 的調整經驗筆記</h2></header><div class=entry-content><p>我們的專案已經有 816 snapshot tests 並且有 600 張 snapshots，對專案的 coverage 約 47%，對產品的品質信心算是滿足夠的。
常被抱怨的點是在 CI 上跑 unit test 的時間太久，以專案 800 多個 snapshot tests 來說需要花上 15 mins 才能跑完，有時候開的 PR 一多幾乎都是在等待 unit test 跑結束，反而有點浪費在等待，目前只能採取折衷的作法，在特定的 branch 才啟動 unit test。
另外遇到的問題是不同機器配上對應的模擬器有時候會發生圖片”看起來”是一樣內容，但檔案大小卻差了幾個 bytes，所以程式比對圖片就直接認定 assert failed。原因是畫面在截取的當下可能仍會因為動畫等視覺效果，而造成產生的 snapshot 有些微色彩的差異。
這類問題的解法目前是走 duplicate image detection 的做法，也就是算出 snapshot 對應的 hash 值，然後將兩張圖片的 hash 根據 Hamming distance 來評估是不是一樣的圖片。
本來是在這邊 GitHub – benhoyt/dhash 看到這個，查了一下大概就是這幾種 hash 方法的比較，來源是 GitHub – ameingast/cocoaimagehashing 這裡：
Name Performance Quality aHash good bad dHash excellent good pHash bad excellent 其實滿推崇 pHash 的方法，看 別人分享 iOS 上測試的過程 具有很多優勢；但因為 dHash 實作上相對容易，也滿多實作的作品可以參考。自己參考的實作是這兩篇：...</p></div><footer class=entry-footer><span title='2022-03-02 00:00:00 +0000 UTC'>March 2, 2022</span>&nbsp;·&nbsp;Keanu Pang</footer><a class=entry-link aria-label="post link to Snapshot Testing 的調整經驗筆記" href=https://keanupang.github.io/posts/ios-snapshot-testing-note/></a></article><article class=post-entry><header class=entry-header><h2>Some useful CLI tools for myself</h2></header><div class=entry-content><p>列幾個針對檔案操作的 CLI 工具是我在平日工作時比較常會用到的，最常用的就是 AG 了，在查找專案目錄下的特定關鍵字顯得非常方便快速。
AG: 用來查找目錄下的所有符合指定文字的檔案內容 fd: 用來查找目錄下所有符合指定文字的檔名 bat: 替換 cat 指令的好工具 sd: 尋找與取代指定檔案裡的文字內容，快又有效</p></div><footer class=entry-footer><span title='2022-02-16 00:00:00 +0000 UTC'>February 16, 2022</span>&nbsp;·&nbsp;Keanu Pang</footer><a class=entry-link aria-label="post link to Some useful CLI tools for myself" href=https://keanupang.github.io/posts/useful_cli_tools_for_myself/></a></article><article class=post-entry><header class=entry-header><h2>ArangoDB 的資料檔備份與還原</h2></header><div class=entry-content><p>之前在測試 ArangoDB 操作特別註記下來的小筆記。
建立 dump unix> arangodump --server.endpoint tcp://&lt;host>:&lt;port> --server.database &lt;database> --include-system-collections --collection _graphs --collection imdb_vertices --collection imdb_edges --compress-output false --envelope true 還原資料 準備好之前 dump 的資料，目前名為 dump，再執行如下指令，預設會找當前目錄下的 dump 目錄：
unix> arangorestore --server.endpoint tcp://&lt;host>:&lt;port> --server.database IMDB --create-database --include-system-collections</p></div><footer class=entry-footer><span title='2021-12-09 00:00:00 +0000 UTC'>December 9, 2021</span>&nbsp;·&nbsp;Keanu Pang</footer><a class=entry-link aria-label="post link to ArangoDB 的資料檔備份與還原" href=https://keanupang.github.io/posts/arangodb_data_dump_and_restore/></a></article><article class=post-entry><header class=entry-header><h2>快速實驗與驗證功能的小工具 swift-sh</h2></header><div class=entry-content><p>OK, 我們現在可以用 swift-sh 工具預先安裝到系統裡，這樣子之後只要做小型測試時只要單一個 swift 檔案，裡面標註 import 的敘述，就可以直接執行它。
先安裝好 swift-sh 工具：
brew install swift-sh 然後就可以開始編寫 swift 檔案做小型的驗證：
#!/usr/bin/swift sh import Foundation import PromiseKit // @mxcl ~> 6.5 firstly { after(.seconds(2)) }.then { after(.milliseconds(500)) }.done { print("notice: two and a half seconds elapsed") exit(0) } RunLoop.main.run() 要記得檔案最前面的 shebang 要寫明 #!/usr/bin/swift sh 的敘述，這樣系統才會去觸發 swift-sh 工具來處理；以及 import 第三方套件時，要在該行的最後加上註解是哪個 SwiftPM 的來源，甚至可以標註版本。
最後只要把這個檔案加上可執行權限就可以直接執行了。</p></div><footer class=entry-footer><span title='2021-12-03 00:00:00 +0000 UTC'>December 3, 2021</span>&nbsp;·&nbsp;Keanu Pang</footer><a class=entry-link aria-label="post link to 快速實驗與驗證功能的小工具 swift-sh" href=https://keanupang.github.io/posts/tool_swift_sh_for_prototyping/></a></article><article class=post-entry><header class=entry-header><h2>工程師的成長</h2></header><div class=entry-content><p>https://limboy.me/2021/06/29/eng-growth
我覺得這篇寫算不錯，把一些必備的項目要點都有列出，對我來說反而是以下幾點比較關鍵：
累積 credit 信用值，才能提升影響力，講話才能大聲，別人才聽得進去 向各類型不同的夥伴學習他們的長處，儘管他們有著自己在意的缺點也沒關係，只要把重點擺在他們的長處並學習 如果對方是你欣賞的，要珍惜與他們共事的時間，遇到問題時，了解他們怎麼看待、處理、解決問題的</p></div><footer class=entry-footer><span title='2021-11-30 00:00:00 +0000 UTC'>November 30, 2021</span>&nbsp;·&nbsp;Keanu Pang</footer><a class=entry-link aria-label="post link to 工程師的成長" href=https://keanupang.github.io/posts/web-share-limboy-eng-growth/></a></article><article class=post-entry><header class=entry-header><h2>BehaviorRelay 筆記</h2></header><div class=entry-content><p>因為是單向的資訊流，在每次更新資訊時都是用 .accept 送出最近資訊，所以最好的做法是如果本身的資訊是組合性的 struct 則拆開成數個 BehaviorRelay 各別更新會比較好，這樣綁定在不同的 UIView 元件會比較好處理。
例如本來是長這樣：
struct Info { var propertyA: Bool = false var propertyB: Bool = false var propertyC: Bool = false } 就拆成三個 property 各自維護：
let propertyA = BehaviorRelay&lt;Bool>(value: false) let propertyB = BehaviorRelay&lt;Bool>(value: false) let propertyC = BehaviorRelay&lt;Bool>(value: false) 然後就可以在 ViewController 層各別 Driver 綁定； 在最後如果需要組合判斷時才在用 Observable.combineLatest 來處理，例如：
var isEnable: Driver&lt;Bool> { return Observable.combineLatest(propertyA, propertyB, propertyC) .map { $0 && $1 && $2 } ....</p></div><footer class=entry-footer><span title='2021-10-26 00:00:00 +0000 UTC'>October 26, 2021</span>&nbsp;·&nbsp;Keanu Pang</footer><a class=entry-link aria-label="post link to BehaviorRelay 筆記" href=https://keanupang.github.io/posts/behavior-relay-note/></a></article><article class=post-entry><header class=entry-header><h2>Failable Initializer 筆記</h2></header><div class=entry-content><p>之前在 這篇文章 看到的。
將自己的 class 來做出一個可以是 optional 的物件，這樣一來使用的時候就必須用 if-let 或 guard 來讀取，在程式上會比較好理解跟處理。
直接上 code：
class FilteredImage { ... init?(with imageName: String) { guard let image = UIImage(named: imageName) else { return nil } self.image = image } } 也就是說在初始化時是用 init? 的方式，確保回傳得到的物件要嘛是 nil 要嘛真的有值，而且對應的屬性也保證有值。
使用上也因為初始化回傳的是 optional 物件，限制了使用者必須用 if-let 或 guard 來拿取：
guard let filteredImage = FilteredImage(with: "bird") else { // filteredImage is nil return } // filteredImage is initialized and we use it normally 然後要保持一個原則，回傳是 nil 一定是因為初始化失敗而得到的，如果是後面的行為造成的話等於權責不分無法抓住問題：...</p></div><footer class=entry-footer><span title='2021-06-01 00:00:00 +0000 UTC'>June 1, 2021</span>&nbsp;·&nbsp;Keanu Pang</footer><a class=entry-link aria-label="post link to Failable Initializer 筆記" href=https://keanupang.github.io/posts/failable_initializer/></a></article><article class=post-entry><header class=entry-header><h2>曾幾何時，人生的種種行為必須要虛偽的表現才算是正常了</h2></header><div class=entry-content><p>自己所說的話所做的事，這些行為都要做的很表面做到位，對方才能夠體會到那所謂的”誠意”，很像電視節目的八點檔戲劇對話般，要正面有多正面，要積極就給到超過 100 分的積極。
對自己來說，大概也只剩下在停車場停完車後坐在駕駛座上遲遲不走的那時刻，才能感覺到真實自己的存在吧。</p></div><footer class=entry-footer><span title='2021-04-30 00:00:00 +0000 UTC'>April 30, 2021</span>&nbsp;·&nbsp;Keanu Pang</footer><a class=entry-link aria-label="post link to 曾幾何時，人生的種種行為必須要虛偽的表現才算是正常了" href=https://keanupang.github.io/posts/hypocritical-person-in-my-life/></a></article><article class=post-entry><header class=entry-header><h2>建立 DynamoDB 的 Incremental ID 機制</h2></header><div class=entry-content><p>需要在 DynamoDB 的某個 table 的 Hash Key 是用 auto increment 的方式儲存 id，不過如果只單靠一張 table 有點難完成這樣的機制，所以需要再生另一張 table 用來存放目前的值，讓原本的 table 可以去參考以取得新增後的數值回來儲存。
可以參考這篇：How to make a UUID in DynamoDB?，做法大概就是像這樣：
Each time you want to generate a new id, you would do the following:
Do a GetItem on NextIdTable to read the current value of Counter → curValue
Do a PutItem on NextIdTable to set the value of Counter to curValue + 1. Make this a conditional > PutItem so that it will fail if the value of Counter has changed....</p></div><footer class=entry-footer><span title='2017-12-12 00:00:00 +0000 UTC'>December 12, 2017</span>&nbsp;·&nbsp;Keanu Pang</footer><a class=entry-link aria-label="post link to 建立 DynamoDB 的 Incremental ID 機制" href=https://keanupang.github.io/posts/dynamodb-incremental-id/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://keanupang.github.io/posts/page/2/>Next »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://keanupang.github.io>Living today for tomorrow</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>