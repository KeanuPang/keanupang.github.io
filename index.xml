<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Living today for tomorrow</title><link>https://keanupang.github.io/</link><description>Recent content on Living today for tomorrow</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 02 Sep 2022 10:26:31 +0800</lastBuildDate><atom:link href="https://keanupang.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust Extensions with VS Code</title><link>https://keanupang.github.io/posts/rust-development-vscode/</link><pubDate>Fri, 02 Sep 2022 10:26:31 +0800</pubDate><guid>https://keanupang.github.io/posts/rust-development-vscode/</guid><description>最近在初學 Rust 然後為了要在 VS Code 裡能有較好的開發體驗，所以找了幾個還不錯的 extensions 方便使用。
rust-analyzer
必裝的工具，我自己是安裝 Pre-Release 的版本先享受比較新的功能，目前使用上算穩定。
Event Better TOML
會幫忙將 toml 檔案內容檢查語法跟 syntax highlighting，另外也有貼心的 formatting 跟 folding 功能，在編輯 toml 檔案會方便很多。
crates
這工具最讓我驚豔的功能是在編輯 Cargo.toml 檔案的 dependencies 時，可以做版本的檢查，引用的版本如果沒問題就會顯示綠色勾勾，這其實會給開發者比較大的信心確認 dependency 版本： CodeLLDB
為了能 debug Rust 所以需要裝上這套工具，就可以在指定的中斷點上查看變數跟 call stack 等 debug 操作。
就目前來說，這幾個工具已經有滿足需求，在開發上的體驗也滿正面，已經很久沒有花時間力氣在 VS Code 上面，希望這個過程能一切順利。</description></item><item><title>My Mac Dev Tools</title><link>https://keanupang.github.io/posts/my-mac-dev-tools/</link><pubDate>Fri, 05 Aug 2022 10:10:35 +0800</pubDate><guid>https://keanupang.github.io/posts/my-mac-dev-tools/</guid><description>update 2022-09-02: Edge Extension 部份加上 SwissTransfer 服務
最近正在整理公司電腦的作業環境，先集結成工具清單這樣方便之後換電腦就可以快速 setup 好。做程式開發常用的工具軟體就不列上去了，反正該做什麼工作就會對應到什麼軟體，基本上大家會使用的都是那幾套，所以這邊只記錄我自己偏好使用的工具集。
Menu Bar Shuttle 非常老牌的 SSH 快速啟動器，只要一個簡單的設定檔就可以把常連的 ssh 登入資訊建立成清單方便快速點選就可以開 terminal 連上；開發環境通常自己會在遠端再設定好 passwordless 登入。這種小工具其實也不用常常更新只要專做好這個重點功能就很好用了。
Input Source Pro 在不同 Apps 間切換常會遇到輸入法的干擾，之前看到有人分享這個工具就是解決輸入法的問題，可以為每個 App 設定專門的規則把鍵盤鎖在指定的輸入法，真的是完全解決我們東方人在切換輸入法的困擾。
Raycast 用來取代以前在用的 Alfred，對我來說只要能快速開啟要操作的 Apps 這個功能就好。
Dato 在角落顯示日期時間等資訊，這很重要。點了日期之後會下拉出 calendar 的資訊，這更重要更方便。所以自然也成為我常用的工具之一。
Shottr 用來截圖之後可以有基本工具對截圖內容做標註，是目前找到算美觀且簡單方便操作的截圖工具。
Magnet 在接大螢幕時比較常會將重點的視窗都排列好，所以都是靠這個工具來快速設定。
MonitorControl 也是在外接螢幕時很方便可以設定顯示亮度跟音量調整，必備的基本重要工具之一。
coconutBattery 可以在 menu bar 上顯示比較直覺得的電池電量的基本資訊，比原本 MacOS 陽春的電量顯示好用多了。
Folder Peek 這是最近才掛上來的工具，主要是可以把工作上常會用到的幾個工作目錄都設定快捷入口，方便在 menu bar 上直接切換過去。
Desktop Tools SmartGit Git 工具的唯一首選，我有付費 lifetime 的授權，用了七八年吧我想完全沒有缺點可講。每每看到同事還在為了 merge/rebase 跟檔案 conflict 問題在 Sourcetree 裡胡搞我就內心一把冷汗。</description></item><item><title>套件組合技經驗：JSON Server</title><link>https://keanupang.github.io/posts/json-server-deformation/</link><pubDate>Mon, 04 Jul 2022 00:00:18 +0800</pubDate><guid>https://keanupang.github.io/posts/json-server-deformation/</guid><description>前陣子因為在開發環境需要有個簡易又不會太粗糙的 mock server，所以快速用短短的時間把幾個套件組合串起來，成為基本可用的迷你 project，最主要還是拜豐富 NodeJS 的生態系所賜，很多東西都有現成可用幾乎不用多寫幾行程式碼，原則上就是可以推到開發環境。
一開始先找到最熱門的 json server 就是 typicode 的專案，跑起來基本上已經符合需求，所以從這邊開始來組合。
如果是用程式碼方式建立 json server 來做客製化，其實骨子裡就是 express web framework，所以用法都是一樣：
const https = require(&amp;#34;https&amp;#34;); const devcert = require(&amp;#34;devcert&amp;#34;); const jsonServer = require(&amp;#34;json-server&amp;#34;); const server = jsonServer.create(); server.use(jsonServer.defaults()); server.use(jsonServer.rewriter(require(&amp;#34;./routes.json&amp;#34;))); server.use(jsonServer.router(&amp;#34;api.json&amp;#34;)); async function start() { let ssl = await devcert.certificateFor(&amp;#34;api.dev&amp;#34;); https.createServer(ssl, server).listen(8443); } start(); 開發環境希望也是走 HTTPS 方式所以用到 devcert 掛了一個自簽的開發用憑證就可以跑 HTTPS 了，如上幾乎就是開箱即用的 server。
由於需要 db.json 檔裡面就是擺好被視為資料庫的 JSON 內容，然後依 request 的 HTTP method 進行資料的 CRUD，但也因為這個很棒的特性所以為了我自己的需求只好魔改原本程式變成 json-server-deformation。</description></item><item><title>試玩 Hummingbird 的 middleware</title><link>https://keanupang.github.io/posts/side-project-hummingbird-localweb/</link><pubDate>Tue, 28 Jun 2022 02:05:11 +0800</pubDate><guid>https://keanupang.github.io/posts/side-project-hummingbird-localweb/</guid><description>之前為了測試 Hummingbird 這個輕量 server framework 所以做了一個叫 LocalWeb 的 web project，主要是用來讓使用者在開發環境下方便地瀏覽與下載檔案；結果沒想到內建的 middleware 就幾乎把所有事情都搞定了。
當然還是要再加點工才可以方便使用，例如當我點進目錄時，希望可以一覽目錄下的檔案清單，所以就客製化做了個 middleware 掛上來，把目錄下的檔案展開成清單做成連結讓使用者可以下載，當使用者點到檔案時就直接串到 HBFileMiddleware 下載檔案這樣。
第一次嘗試實作 Hummingbird 的 middleware 所以花了點時間研究，目前實作版本可以參考這 DirectoryIndexMiddleware ，還好進入門檻不高就是，花最多時間反而是在刻呈現頁面的 html。
因為想呈現那種傳統 Apache web server 檢視目錄下的復古感，於是參考 HBResponseGenerator 這個 protocol，是用來產生 response 結果頁，基本上只要實作 func response(from request: HBRequest) 把刻好的 html 產生成 HBResponse 結果就可以。
成品像是這樣 DirectoryIndexPage 會在剛剛的 DirectoryIndexMiddleware 裡被用到回傳 response。
為了求快所以先不套用什麼 template engine，直接用 String 拼出來，之後有時間再研究看看 Stencil 還是 Leaf 哪個好用。
雛型差不多完成之後，想說要掛個 HTTPS 功能結果好像沒有那麼直覺。本來以為只要把 Configuration 裡的 tlsOptions 設定上去就好，然後就會被噴 warning 訊息：
tlsOptions set in Configuration will not be applied to a BSD sockets server.</description></item><item><title>About Me</title><link>https://keanupang.github.io/about/</link><pubDate>Wed, 22 Jun 2022 13:45:57 +0800</pubDate><guid>https://keanupang.github.io/about/</guid><description/></item><item><title>幾個 WebView 互動功能筆記</title><link>https://keanupang.github.io/posts/ios-webview-note/</link><pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/ios-webview-note/</guid><description>好像只有在亞洲地區才流行這樣的組合，也就是從 native app 畫面開 web view 切到行銷活動網頁，再透過 javascript 方式跟 app 互動之後回到 app 裡進行後面的導頁與串行銷資料。
同步切換 app 畫面標題 為了要讓 webView 載入的網頁標題也能貼回到 App 裡的 navigation bar 上，所以在 viewDidLoad() 的時候，加上 addObserver：
webView.addObserver(self, forKeyPath: #keyPath(WKWebView.title), options: .new, context: nil) 為了避免 leak，若有開啟 addObserver 更新 title 的話，在 ViewController dismiss 時要移除掉：
webView.removeObserver(self, forKeyPath: &amp;#34;title&amp;#34;) 顯示與取消 Loading 對應到 WKNavigationDelegate 可以透過下方兩個 methods 顯示或取消自訂的 loading view：
func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) { guard isBeingDismissed || isMovingFromParent else { // present loading view return } } func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!</description></item><item><title>Snapshot Testing 的調整經驗筆記</title><link>https://keanupang.github.io/posts/ios-snapshot-testing-note/</link><pubDate>Wed, 02 Mar 2022 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/ios-snapshot-testing-note/</guid><description>我們的專案已經有 816 snapshot tests 並且有 600 張 snapshots，對專案的 coverage 約 47%，對產品的品質信心算是滿足夠的。
常被抱怨的點是在 CI 上跑 unit test 的時間太久，以專案 800 多個 snapshot tests 來說需要花上 15 mins 才能跑完，有時候開的 PR 一多幾乎都是在等待 unit test 跑結束，反而有點浪費在等待，目前只能採取折衷的作法，在特定的 branch 才啟動 unit test。
另外遇到的問題是不同機器配上對應的模擬器有時候會發生圖片”看起來”是一樣內容，但檔案大小卻差了幾個 bytes，所以程式比對圖片就直接認定 assert failed。原因是畫面在截取的當下可能仍會因為動畫等視覺效果，而造成產生的 snapshot 有些微色彩的差異。
這類問題的解法目前是走 duplicate image detection 的做法，也就是算出 snapshot 對應的 hash 值，然後將兩張圖片的 hash 根據 Hamming distance 來評估是不是一樣的圖片。
本來是在這邊 GitHub – benhoyt/dhash 看到這個，查了一下大概就是這幾種 hash 方法的比較，來源是 GitHub – ameingast/cocoaimagehashing 這裡：
Name Performance Quality aHash good bad dHash excellent good pHash bad excellent 其實滿推崇 pHash 的方法，看 別人分享 iOS 上測試的過程 具有很多優勢；但因為 dHash 實作上相對容易，也滿多實作的作品可以參考。自己參考的實作是這兩篇：</description></item><item><title>Some useful CLI tools for myself</title><link>https://keanupang.github.io/posts/useful_cli_tools_for_myself/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/useful_cli_tools_for_myself/</guid><description>列幾個針對檔案操作的 CLI 工具是我在平日工作時比較常會用到的，最常用的就是 AG 了，在查找專案目錄下的特定關鍵字顯得非常方便快速。
AG: 用來查找目錄下的所有符合指定文字的檔案內容 fd: 用來查找目錄下所有符合指定文字的檔名 bat: 替換 cat 指令的好工具 sd: 尋找與取代指定檔案裡的文字內容，快又有效</description></item><item><title>ArangoDB 的資料檔備份與還原</title><link>https://keanupang.github.io/posts/arangodb_data_dump_and_restore/</link><pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/arangodb_data_dump_and_restore/</guid><description>之前在測試 ArangoDB 操作特別註記下來的小筆記。
建立 dump unix&amp;gt; arangodump --server.endpoint tcp://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt; --server.database &amp;lt;database&amp;gt; --include-system-collections --collection _graphs --collection imdb_vertices --collection imdb_edges --compress-output false --envelope true 還原資料 準備好之前 dump 的資料，目前名為 dump，再執行如下指令，預設會找當前目錄下的 dump 目錄：
unix&amp;gt; arangorestore --server.endpoint tcp://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt; --server.database IMDB --create-database --include-system-collections</description></item><item><title>快速實驗與驗證功能的小工具 swift-sh</title><link>https://keanupang.github.io/posts/tool_swift_sh_for_prototyping/</link><pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/tool_swift_sh_for_prototyping/</guid><description>OK, 我們現在可以用 swift-sh 工具預先安裝到系統裡，這樣子之後只要做小型測試時只要單一個 swift 檔案，裡面標註 import 的敘述，就可以直接執行它。
先安裝好 swift-sh 工具：
brew install swift-sh 然後就可以開始編寫 swift 檔案做小型的驗證：
#!/usr/bin/swift sh import Foundation import PromiseKit // @mxcl ~&amp;gt; 6.5 firstly { after(.seconds(2)) }.then { after(.milliseconds(500)) }.done { print(&amp;#34;notice: two and a half seconds elapsed&amp;#34;) exit(0) } RunLoop.main.run() 要記得檔案最前面的 shebang 要寫明 #!/usr/bin/swift sh 的敘述，這樣系統才會去觸發 swift-sh 工具來處理；以及 import 第三方套件時，要在該行的最後加上註解是哪個 SwiftPM 的來源，甚至可以標註版本。
最後只要把這個檔案加上可執行權限就可以直接執行了。</description></item><item><title>工程師的成長</title><link>https://keanupang.github.io/posts/web-share-limboy-eng-growth/</link><pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/web-share-limboy-eng-growth/</guid><description>https://limboy.me/2021/06/29/eng-growth
我覺得這篇寫算不錯，把一些必備的項目要點都有列出，對我來說反而是以下幾點比較關鍵：
累積 credit 信用值，才能提升影響力，講話才能大聲，別人才聽得進去 向各類型不同的夥伴學習他們的長處，儘管他們有著自己在意的缺點也沒關係，只要把重點擺在他們的長處並學習 如果對方是你欣賞的，要珍惜與他們共事的時間，遇到問題時，了解他們怎麼看待、處理、解決問題的</description></item><item><title>BehaviorRelay 筆記</title><link>https://keanupang.github.io/posts/behavior-relay-note/</link><pubDate>Tue, 26 Oct 2021 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/behavior-relay-note/</guid><description>因為是單向的資訊流，在每次更新資訊時都是用 .accept 送出最近資訊，所以最好的做法是如果本身的資訊是組合性的 struct 則拆開成數個 BehaviorRelay 各別更新會比較好，這樣綁定在不同的 UIView 元件會比較好處理。
例如本來是長這樣：
struct Info { var propertyA: Bool = false var propertyB: Bool = false var propertyC: Bool = false } 就拆成三個 property 各自維護：
let propertyA = BehaviorRelay&amp;lt;Bool&amp;gt;(value: false) let propertyB = BehaviorRelay&amp;lt;Bool&amp;gt;(value: false) let propertyC = BehaviorRelay&amp;lt;Bool&amp;gt;(value: false) 然後就可以在 ViewController 層各別 Driver 綁定； 在最後如果需要組合判斷時才在用 Observable.combineLatest 來處理，例如：
var isEnable: Driver&amp;lt;Bool&amp;gt; { return Observable.combineLatest(propertyA, propertyB, propertyC) .map { $0 &amp;amp;&amp;amp; $1 &amp;amp;&amp;amp; $2 } .</description></item><item><title>Failable Initializer 筆記</title><link>https://keanupang.github.io/posts/failable_initializer/</link><pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/failable_initializer/</guid><description>之前在 這篇文章 看到的。
將自己的 class 來做出一個可以是 optional 的物件，這樣一來使用的時候就必須用 if-let 或 guard 來讀取，在程式上會比較好理解跟處理。
直接上 code：
class FilteredImage { ... init?(with imageName: String) { guard let image = UIImage(named: imageName) else { return nil } self.image = image } } 也就是說在初始化時是用 init? 的方式，確保回傳得到的物件要嘛是 nil 要嘛真的有值，而且對應的屬性也保證有值。
使用上也因為初始化回傳的是 optional 物件，限制了使用者必須用 if-let 或 guard 來拿取：
guard let filteredImage = FilteredImage(with: &amp;#34;bird&amp;#34;) else { // filteredImage is nil return } // filteredImage is initialized and we use it normally 然後要保持一個原則，回傳是 nil 一定是因為初始化失敗而得到的，如果是後面的行為造成的話等於權責不分無法抓住問題：</description></item><item><title>曾幾何時，人生的種種行為必須要虛偽的表現才算是正常了</title><link>https://keanupang.github.io/posts/hypocritical-person-in-my-life/</link><pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/hypocritical-person-in-my-life/</guid><description>自己所說的話所做的事，這些行為都要做的很表面做到位，對方才能夠體會到那所謂的”誠意”，很像電視節目的八點檔戲劇對話般，要正面有多正面，要積極就給到超過 100 分的積極。
對自己來說，大概也只剩下在停車場停完車後坐在駕駛座上遲遲不走的那時刻，才能感覺到真實自己的存在吧。</description></item><item><title>建立 DynamoDB 的 Incremental ID 機制</title><link>https://keanupang.github.io/posts/dynamodb-incremental-id/</link><pubDate>Tue, 12 Dec 2017 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/dynamodb-incremental-id/</guid><description>需要在 DynamoDB 的某個 table 的 Hash Key 是用 auto increment 的方式儲存 id，不過如果只單靠一張 table 有點難完成這樣的機制，所以需要再生另一張 table 用來存放目前的值，讓原本的 table 可以去參考以取得新增後的數值回來儲存。
可以參考這篇：How to make a UUID in DynamoDB?，做法大概就是像這樣：
Each time you want to generate a new id, you would do the following:
Do a GetItem on NextIdTable to read the current value of Counter → curValue
Do a PutItem on NextIdTable to set the value of Counter to curValue + 1. Make this a conditional &amp;gt; PutItem so that it will fail if the value of Counter has changed.</description></item><item><title>在 Observable 裡做 recursive 操作</title><link>https://keanupang.github.io/posts/rxjs-expand-operator/</link><pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/rxjs-expand-operator/</guid><description>請參考 expand operator 的說明：
Recursively projects each source value to an Observable which is merged in the output Observable. 在 expand operator 裡主要的判斷是如果離開這個 recursion 就回傳 Rx.Observable.empty()；反之就把需要 recursive 的值修改後再回傳 Observable 物件，於是你的 Observable 物件就可以做類似 loop 的叫用串接了。
小範例如下，是用 AVA 做 test runner：
const Rx = require(&amp;#39;rxjs&amp;#39;); const winston = require(&amp;#39;winston&amp;#39;); const test = require(&amp;#39;ava&amp;#39;); const fetchObs = (count) =&amp;gt; { return Rx.Observable.of({value: count, count: count*2}); }; test(&amp;#39;test expand&amp;#39;, (t) =&amp;gt; { return fetchObs(1) .</description></item><item><title>Connect-Redis 套件更新 Session 過期時間的方式</title><link>https://keanupang.github.io/posts/configure-redis-session-timeout/</link><pubDate>Mon, 14 Nov 2016 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/configure-redis-session-timeout/</guid><description>在使用 Express 架設網站時，且因為 cluster 的考量，會將 Session cookie 的資訊往外拉，通常都是使用 Redis 來儲存使用者的 Session。在 Express 裡會透過 connect-redis 的套件來串接兩者，以及使用者登入的檢查就使用 passport 套件來幫我們完成。
在 Express 裡的設定結構大概會是這樣︰
let sessionMiddleware = session({ store: new RedisStore({ host: hostname, port: port, db: db * 1, ttl: 3600 }), resave: false, saveUninitialized: false }); app.middleware(‘session’, sessionMiddleware); 這時候的困難點會是當未登入的使用者可能需要 session cookie 的 maxAge 會比較短期，例如需要是處在 recaptcha 的驗證階段；直到使用者順利登入後，才需要更新 session cookie 的 maxAge 為合理的時間。也就是 Redis 的 TTL 設定是動態的方式調整。
參考這裡的 討論 的做法則會是固定將 TTL 設為 0，並在使用者登入後才更新 maxAge。所以 RedisStore 的設定將會是︰</description></item><item><title>自定 Retrofit 的 DELETE Annotation</title><link>https://keanupang.github.io/posts/custom-retrofit-delete-annotation/</link><pubDate>Wed, 04 May 2016 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/custom-retrofit-delete-annotation/</guid><description>一般使用 Jersey 或 RESTEasy 所建立的 JAX-RS Web Service，是允許 client 呼叫 DELETE method 時可以加上 Message Body，就跟 POST method 一樣我們可以取得 Body 裡的內容。
但 Client 如果是使用 Retrofit 來呼叫 Web Service 的 DELETE method 並且加上 Body annotation 夾帶資料過去時，卻會得到如下的訊息而被中止︰
Non-body HTTP method cannot contain @Body or @TypedOutput. 對 Retrofit 來說是照著 W3C 的標準去實作，於是這樣的行為就跟一般坊間的 http client 不太一樣。
最快的方法就是自定一個可以允許夾帶資料的 DELETE Annotation，讓 Retrofit 可以參照︰
import static java.lang.annotation.ElementType.METHOD; import static java.lang.annotation.RetentionPolicy.RUNTIME; import java.lang.annotation.Retention; import java.lang.annotation.Target; import retrofit.http.RestMethod; @Target(METHOD) @Retention(RUNTIME) @RestMethod(value = “DELETE”, hasBody = true) public @interface DELETE { String value(); } 然後在自己的 Retrofit Service 使用這個 DELETE annotation 就可以了︰</description></item><item><title>Create a Self-Signed Certificate</title><link>https://keanupang.github.io/posts/create-self-signed-certificate/</link><pubDate>Sat, 30 Apr 2016 00:00:00 +0000</pubDate><guid>https://keanupang.github.io/posts/create-self-signed-certificate/</guid><description>在工作上因為每過一陣子就會用到，但又常常忘記步驟所以筆記一下。
先用 opeenssl 指令產生私鑰跟 CSR 檔︰
openssl req -x509 -sha256 -days 3652 -newkey rsa:2048 -keyout server.key -out server.csr 建立憑證檔案︰
openssl x509 -sha256 -days 3652 -in server.csr -signkey server.key -out selfsigned.crt 將剛剛的憑證檔案轉成 P12 格式︰
openssl pkcs12 -export -name cert_server -in selfsigned.crt -inkey server.key -out keystore.p12 最後透過 Java 的 keytool 工具轉成適合 Java 環境使用的 JKS 格式憑證檔案︰
keytool -importkeystore -destkeystore keystore.jks -srckeystore keystore.p12 -srcstoretype pkcs12 -alias cert_server 完成收工。</description></item></channel></rss>